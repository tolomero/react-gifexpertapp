{"version":3,"sources":["Components/AddCategory.js","helpers/getGifs.js","Components/GifGridItem.js","Components/GifGrid.js","hooks/useFetchGifts.js","GifExpertApp.js","index.js"],"names":["AddCategory","setcategories","useState","imputValue","setImputValue","counter","setcounter","onSubmit","e","preventDefault","prevContador","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","setTimeout","console","log","useFetchGifts","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAQaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EAKZC,mBAAS,IALG,mBAKzCC,EALyC,KAK7BC,EAL6B,OAMlBF,mBAAS,GANS,mBAMzCG,EANyC,KAMhCC,EANgC,KAyC5C,OAKI,cAJA,CAIA,QAAMC,SAnCQ,SAACC,GAClBA,EAAEC,iBACFH,GAAW,SAACI,GACT,OAAOA,EAAe,KAKtBP,EAAWQ,OAAOC,QAAU,IAM5BX,GAAe,SAAAY,GAAI,OAAMV,GAAN,mBAAqBU,OAGxCT,EAAc,MAkBd,UACA,+BAAOD,EAAaE,IAChB,uBACIS,KAAM,OACNC,MAAQZ,EAGRa,SA9CW,SAACR,GAEvBJ,EAAcI,EAAES,OAAOF,c,+BCZfG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAObC,EAPa,iDAOoCC,UAAWH,GAP/C,+DAQAI,MAAOF,GARP,cAQbG,EARa,gBASIA,EAAKC,OATT,uBASXC,EATW,EASXA,KAKFC,EAAOD,EAAKE,KAAI,SAAAC,GAAO,IAAD,EACxB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAlBvB,kBAsBZM,GAtBY,4CAAH,sDCDPO,EAAc,SAAC,GAAoB,IAAlBH,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAMjC,OAEI,cADA,CACA,OAAKc,UAAU,yCAAf,UAEI,qBAAKC,IAAMf,EAAMgB,IAAMN,IACvB,kCAAMA,EAAN,WCJCO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECPZ,SAAEA,GAAgB,IAAD,EACjBjB,mBAAS,CAChCwB,KAAM,GACNa,SAAS,IAH+B,mBACpCC,EADoC,KAC7BC,EAD6B,KA+B3C,OAzBAC,qBAAY,WACXxB,EAASC,GACRwB,MAAK,SAAAC,GAGFC,YAAW,WACPC,QAAQC,IAAIH,GACpBH,EAAS,CACLf,KAAMkB,EACNL,SAAS,MAGN,UAGL,CAACpB,IAUGqB,EDjB2BQ,CAAe7B,GAAnCa,EAPwB,EAO7BN,KAAaa,EAPgB,EAOhBA,QAuDrB,OAtDAO,QAAQC,IAAKf,GAuDT,qCACE,qBAAIG,UAAU,uCAAd,UAAuDhB,EAAvD,OAGCoB,GAAW,mBAAGJ,UAAU,uCAAb,qBAEV,qBAAKA,UAAU,YAAf,SAIQH,EAAOJ,KAAK,SAAAC,GAAG,OAEX,aADJ,CACK,EAAD,eAGIA,GAFCA,EAAIC,aElFpBmB,EAAe,WAAM,MAGM/C,mBAAS,CAAC,cAHhB,mBAGvBgD,EAHuB,KAGXjD,EAHW,KAc9B,OACA,qCACI,gDAEA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBAGA,6BAQIiD,EAAWtB,KAAK,SAAAT,GAAQ,OAChB,cAAC,EAAD,CAEAA,SAAWA,GADNA,Y,MC7BzBgC,IAASC,OACR,cAAC,EAAD,IACCC,SAASC,eAAe,W","file":"static/js/main.54899094.chunk.js","sourcesContent":["import React from 'react'\r\nimport { useState } from 'react'\r\n// import PropTypes from 'prop-types';\r\n\r\n\r\n\r\n// IMPORTANTE PARA RESIVIR LAS PROPIEDADES DE OTRO COMPONENTE SE LE PASAN \r\n// POR props PERO LA MEJOR FORMA ES DESESTRUCTURAR LA FUNCION ESTADO EJEMPLO({setCategories})\r\nexport const AddCategory = ({setcategories}) => {\r\n\r\n    // CREAMOS EL ESTADO QUE VA A CAPTURAR LO QUE ESTAMOS ESCRIBIENDO DENTRO\r\n// DEL InputDeviceInfo.\r\n\r\nconst [imputValue, setImputValue] = useState('')\r\nconst [counter, setcounter] = useState(0)\r\n const handleImputChange = (e) => {\r\n    //  console.log(e.target.value);\r\n     setImputValue(e.target.value);\r\n }\r\n const handleSubmit = (e) => {\r\n     e.preventDefault();\r\n     setcounter((prevContador) => {\r\n        return prevContador + 1\r\n      })\r\n      \r\n    // CONDICION PARA QUE NO ME GUARDE ALGO VACIO\r\n    // Y RESETIAR EL imputValue\r\n    if (imputValue.trim().length >= 0) {\r\n        // ACA ES DONDE PODEMOS CAMBIAR PARA QUE DEJE PRIMO EN LA PAGINA\r\n        // LAS QUE BUSCAMOS Y DESPUES LAS QUE YA ESTAN SE PONE DE \r\n        // SEGUNDAS LAS QUE ESTAN LLAMANDO LAS QUE TENEMOS Y LA NUEVA \r\n        // DE PRIMERAS SI NO SABEMOS COMO SE ENCUENTRA ENCIMA DEL MODULO DE DAMOS F12 \r\n\r\n        setcategories( cats => [ imputValue, ...cats ]);\r\n        // console.log(cats) \r\n        \r\n        setImputValue('');\r\n        // setcounter([imputValue + 1]) \r\n        // console.log(imputValue) \r\n        // setcounter(imputValue => {\r\n        //             return [...imputValue + 1]\r\n        //         });\r\n        \r\n    }\r\n\r\n    // console.log('submit Hecho')\r\n    // setImputValue('')\r\n }\r\n\r\n    return (\r\n        // NOTA EÃ‘L FRAGMEN ES UN AGRUPADOR DE ELEMNETOS \r\n        // Y EL FORMULARIO TAMBIEN EN CASO QUE TENGAMOS UN FORMULARIO\r\n        // NO NECESITAMOS EL FRAGMEN <>\r\n        // <>\r\n        <form onSubmit={ handleSubmit}>\r\n        <span>{imputValue + counter}</span>\r\n            <input\r\n                type= \"text\"\r\n                value={ imputValue }\r\n                // FORMA DE VER LOS EVENTOS DEL IMPUT\r\n                // onChange={(e) => console.log(e) }\r\n                onChange={ handleImputChange }\r\n        \r\n            />\r\n           </form> \r\n        // </>\r\n    )\r\n}\r\n\r\n// CUANDO QUEREMOS LLAMAR UN ELEMNTE DE OTRO COMPONENTE POR PROP-TYPES\r\n// AddCategory.PropTypes = {\r\n//     setcategories: PropTypes.func.isRequired\r\n// }\r\n\r\n","\r\n\r\n\r\n\r\n// aca toca expoportarlo y ver que estado esta usando par allamarlo he importar\r\nexport const getGifs = async( category ) => {\r\n    // ACA BUSCAMOS LA URL EN GUIPHY DEVELOPERS POR SEARCH LA COPIAMOS LA PEGAMOS EN \r\n    // EL PROGRAMA POSTMAN ESCRIBIMO S api_key y alfrente pegamos la url que nos dio\r\n    // la pagina developer le damos en send copiamos la url\r\n    // la pegamos aca en una constante dentro de nuestro componente \r\n    // NOS TOCA AGREGARLEhttps:// y rellenar los espacios con un +\r\n    // ACA PODEMOS CONCATENEAR CON  BACK TICS Y ${category}\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=Hxr0C72n0N54IZwHha8oqAtqxosMahH4`\r\n    const resp = await fetch( url );\r\n    const { data } = await resp.json();\r\n\r\n    // aca estoy creando un map osea barriendo toda la Array\r\n    // y creando una nueva con lo que necesito de ella para eso se ase asi \r\n    // con esta funcion.\r\n    const gifs = data.map(img =>{\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    })\r\n\r\n    return gifs;\r\n    // console.log(gifs);\r\n    // // esto muestra las imagenes como nosotros queriamos\r\n    // setImages( gifs );\r\n}","import React from 'react'\r\n\r\n\r\n// COMOPONENTE PARA MOSTRAR LA LISTA\r\nexport const GifGridItem = ({ title, url }) => {\r\n    // LO QUE ESTE EN EL ARGUMENTO DEL console,LOG(SON LAS PROPS DEL ESTADO IMG)\r\n    // console.log(img);\r\n        // console.log(props);\r\n        // console.log( id, title, url )\r\n\r\n    return (\r\n        // CUANDO DICE CLASSNAME ES POR Q ESTAMOS LLAMANDO EL CSS\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            {/* aca mostramos la imagen ASI: */}\r\n            <img src={ url } alt={ title } />\r\n            <p> { title } </p>\r\n            {/* { img.title } */}\r\n        </div>\r\n    )\r\n}\r\n","// import React, { useEffect } from 'react'\r\nimport React  from 'react';\r\nimport { useFetchGifts } from '../hooks/useFetchGifts';\r\n// import { useState } from 'react';\r\n// import { getGifs } from '../helpers/getGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\n\r\n\r\n\r\n// import { version } from 'react-dom'\r\nexport const GifGrid = ({ category }) => {\r\n\r\n    // ACA ESTAMOS IMPORTANDO EL CUSTON HOOKS Q ES ELE QUE HACE EL LOADING\r\n    // useFetchGifts();\r\n\r\n    // aca se le manda como argumento la categoria\r\n    // cuando se poene data: es para renombrar \r\n    const { data:images, loading } = useFetchGifts( category );\r\n    console.log( images );\r\n\r\n    // ESTADO DONDE NOSOTROS VAMOS A CARGAR LAS IMAGENES QUE QUEREMOS MOSTRAS Y COMO \r\n    // LAS QUEREMOS MOSTRAR\r\n    // const [images, setImages] = useState([]);\r\n// const [count, setCount] = useState(0)\r\n//  useEffect NOS AYUDA A GENERAR CODIGO DE MANERA CONDICIONAL\r\n//  Y PARA QUE ESTA PETICION NO SE ACTUALICE CADA VES QUE  QU EJECUTAMOS EL MODULO DE MANERA INFINITA\r\n// COMO PRIMER ARGUMENTO RECIBE UNA FUNCION Y EL SEGUNDO ARGUMENTO\r\n// QUE LEMANDAMOS VA HACER UN ARREGLO DE DEPENDENCIAS Y SI SE DEJA VACIO\r\n// SOLO SE EJECUTA UNA UNICA veS\r\n// useEffect( () =>{\r\n//     // CUANDO SE CREA LA FUNCION EN EL ARCHIVO HELPER \r\n//     // ESTA FUNCION RETORNA UNA PROMESA NOS TOCA PONER .THEN\r\n//     // se pone una funcion que como primer argumento e mandar una funcion \r\n//     // setImages entonces se pued borrar el img => (imgs)\r\n//     getGifs( category )\r\n//     .then( setImages );\r\n\r\n//     // .then{imgs => setImages( imgs )}\r\n// // CON ESTO QUITAMOS EL WARNING  react hook useEffect has missing dependency\r\n// // POR SI ALGUNA APLICACION HACE DE UNA UNA PETICION HTTP \r\n// },[ category ])\r\n    // esto no tiene que ver con react esto es peticion http de la data\r\n    // const getGifs = async() => {\r\n    //     // ACA BUSCAMOS LA URL EN GUIPHY DEVELOPERS POR SEARCH LA COPIAMOS LA PEGAMOS EN \r\n    //     // EL PROGRAMA POSTMAN ESCRIBIMO S api_key y alfrente pegamos la url que nos dio\r\n    //     // la pagina developer le damos en send copiamos la url\r\n    //     // la pegamos aca en una constante dentro de nuestro componente \r\n    //     // NOS TOCA AGREGARLEhttps:// y rellenar los espacios con un +\r\n    //     // ACA PODEMOS CONCATENEAR CON  BACK TICS Y ${category}\r\n    //     const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=Hxr0C72n0N54IZwHha8oqAtqxosMahH4`\r\n    //     const resp = await fetch( url );\r\n    //     const { data } = await resp.json();\r\n\r\n    //     // aca estoy creando un map osea barriendo toda la Array\r\n    //     // y creando una nueva con lo que necesito de ella para eso se ase asi \r\n    //     // con esta funcion.\r\n    //     const gifs = data.map(img =>{\r\n    //         return {\r\n    //             id: img.id,\r\n    //             title: img.title,\r\n    //             url: img.images?.downsized_medium.url\r\n    //         }\r\n    //     })\r\n\r\n\r\n    //     console.log(gifs);\r\n    //     // esto muestra las imagenes como nosotros queriamos\r\n    //     setImages( gifs );\r\n    // }\r\n    // getGifs();\r\n                // se pone el fragmen o el <> </> por que ya hay dos objetos\r\n            // la clase card-grid va hacer un contenedor de cartas de css\r\n    return (\r\n        <>\r\n          <h1 className=\"animate__animated animate__heartBeat\">{ category } </h1>\r\n          {/* muestra el loadin y se va a los 3 segundos */}\r\n          {/* {loading ? 'cargando...' : 'Carga Completa'} */}\r\n          {loading && <p className=\"animate__animated animate__headShake\">Loading</p>}\r\n           \r\n            <div className=\"card-grid\">\r\n          \r\n            {/* <ol>  */}\r\n                {\r\n                    images.map( img =>(\r\n                    // data.map( img =>(\r\n                        <GifGridItem \r\n                        key={img.id}\r\n                        // img={ img }\r\n                        {...img}\r\n                        />\r\n                    ))\r\n                }\r\n            \r\n             \r\n            {/* <h3>{count}</h3>\r\n            <button onClick={()=> setCount(count + 1 ) }></button> */}\r\n            {/* </ol>         */}\r\n            </div>\r\n       </>     \r\n\r\n    )\r\n}\r\n\r\n\r\n\r\n// {\r\n//     cuando no tenemos las llaves es hacer un return implisito\r\n//     images.map(img =>(\r\n//         <li key={img.id} >{ img.title }</li>\r\n//     ))\r\n//     SI QUERMOS DESESTRUCTURARLOS PODEMOS QUITAR LOS IMG DE ID Y DE TITLE ASI:\r\n//     images.map(({id, title}) =>(\r\n//         <li key={id} >{ title } </li>\r\n//     ))\r\n    \r\n//     ACA LO MOSTRAMOS POR MODULO \r\n\r\n//     images.map( img =>(\r\n//         <GifGridItem \r\n//         key={img.id}\r\n//         // img={ img }\r\n//         {...img}\r\n//         />\r\n//     ))\r\n// }","import { useState, useEffect } from 'react';\r\nimport { getGifs } from '../helpers/getGifs';\r\n// custom hooks no es mas que una funcion que dentro puede tener un estado \r\n// y este en elk estado inicia va hace r un objeto que va a tener un arreglo \r\nexport const useFetchGifts = ( category ) =>  {\r\n   const [state, setState] = useState({\r\n      data: [],\r\n      loading: true\r\n   }); \r\n// los useEffect no pueden ser asyng por que esperan algo sincrono\r\n   useEffect ( () => {\r\n    getGifs( category )\r\n    .then(imgs => {\r\n\r\n        \r\n        setTimeout(()=> {\r\n            console.log(imgs)\r\n    setState({\r\n        data: imgs,\r\n        loading: false\r\n        }); \r\n\r\n        }, 3000);\r\n    })\r\n\r\n   }, [category])\r\n   \r\n//    setTimeout( () => {\r\n//     setState({\r\n//         data: [1,2,3,4,5,6,7],\r\n//         loading: false\r\n//     })\r\n\r\n//    }, 3000 );\r\n\r\n   return state; // el state es igual a: {data:[], loading: true}\r\n\r\n\r\n}","import React, { useState } from 'react';\r\nimport { AddCategory } from './Components/AddCategory';\r\nimport { GifGrid } from './Components/GifGrid';\r\n\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    // const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\r\n    const [categories, setcategories] = useState(['One Punch']);\r\n  \r\n//   const handleClick = () => {\r\n//         // setcategories([...categories, 'HunterXHunter']);\r\n//         // NOTA: ESTA FORMA GNERA UN CALLBACK MEDIANTE UNA Function\r\n//         // QUE DESPUES SE PUEDE VOLVER A REUTILIZAR.\r\n//         setcategories( cats => [...cats, 'HunterXHunter']);\r\n//   }\r\n    // {/* IMPORTATE COMO HACEMOS LA COMUNICACION ENTRE COMPONENTES\r\n    //     ES ASI LE PODEMOS PASARLE PROPIEDADES Adcategorias mediante una funcion \r\n    //     EN ESTE CASO setCategories */}\r\n    return (\r\n    <>\r\n        <h2>Gif Expert App</h2>\r\n      \r\n        <AddCategory setcategories={setcategories} />\r\n        <hr />\r\n        {/* <button onClick={handleClick}>Agregar</button> */}\r\n\r\n        <ol>\r\n        {\r\n            // categories.map( (category, index) => {\r\n            //         return <li key={ index }> { category } </li>   \r\n            //     })     \r\n            // categories.map( category => (\r\n            //      <li key={ category }> { category } </li>\r\n            //      ))   \r\n            categories.map( category => (\r\n                    <GifGrid \r\n                    key={category}\r\n                    category={ category } />\r\n                ))   \r\n            \r\n            \r\n        }\r\n\r\n        </ol>\r\n    </>\r\n   )\r\n};\r\n\r\n// categories.map( (category, index) => {\r\n//     return <li key={ index }> { category } </li>   \r\n// }) ","import React from 'react';\nimport ReactDOM from 'react-dom';\n// import { AddCategory } from './Components/AddCategory';\nimport { GifExpertApp } from './GifExpertApp';\nimport './index.css';\n\n \n\nReactDOM.render(\n <GifExpertApp />,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}